POST >> /login/v3/oauth/access >> Make a POST request to /login/v3/oauth/access to create a token with an authorization code grant. This requires a Base64-encoded client ID and secret in the Authorization header.
POST >> /login/v3/oauth/access >> Make a POST request to /login/v3/oauth/access to obtain a new access_token from a refresh_token. This requires a client ID and secret. Be sure to pass your client_id and secret to Sonos securely. 
DELETE >> /players/{playerId}/audioClip/{id} >> Use the cancelAudioClip command in the audioClip namespace to cancel a specific audio clip from playing. Sonos sends an error if it has already finished playing the selected audio clip.
POST >> /players/{playerId}/audioClip >> Use the loadAudioClip command in the audioClip namespace to schedule an audio clip for playback. The command returns immediately, indicating whether the audio clip was successfully scheduled or not. The player can handle multiple audio clips and implements a simple priority system to determine playback order: A High priority audio clip can interrupt another high priority audio clip if the latter has played for more then 10 seconds. A high priority audio clip can interrupt a low priority audio clip at any time. A low priority audio clip can interrupt a low priority audio clip at any time.
POST >> /players/{playerId}/audioClip/subscription >> Use this command to subscribe to events in the audioClip namespace.
DELETE >> /players/{playerId}/audioClip/subscription >> Use this command to unsubscribe to events in the audioClip namespace.
GET >> /households/{householdId}/favorites >> Use the getFavorites command in the favorites namespace to get the list of Sonos favorites for a household. Favorites do not include pinned items (any non-playable containers pinned to My Sonos) or Sonos playlists. See the Save your favorites section in the Sonos user guide and integrating your service favorites with Sonos on Sonos Labs for details. The player limits the number of Sonos favorites to 70.
POST >> /groups/{groupId}/favorites >> The loadFavorite command in the favorites namespace activates a favorite within the default playback session. This command interrupts any active private playback sessions. Sonos adds album, tracklist, and track favorites to the queue and activates the queue. This prevents your app from overwriting user-curated queues.
POST >> /households/{householdId}/favorites/subscription >> Use this command to subscribe to events in the favorites namespace. When subscribed, Sonos sends asynchronous versionChanged events when users update their Sonos favorites. Your app can then choose to fetch the favorites as needed whenever the version changes. This is because the FavoritesList object can be large for asynchronous events.
DELETE >> /households/{householdId}/favorites/subscription >> Use this command to unsubscribe to events in the favorites namespace.
GET >> /households/{householdId}/groups >> Use the getGroups command in the groups namespace to get information about groups and players in a household.
POST >> /households/{householdId}/groups/createGroup >> Use the createGroup command in the groups namespace to create a new group from a list of players. The player returns a group object with the group ID. This may be an existing group ID if an existing group is a subset of the new group. In this case, Sonos may build the new group by adding new players to the existing group.
POST >> /groups/{groupId}/groups/modifyGroupMembers >> Use the modifyGroupMembers command in the groups namespace to add players to and remove players from a group. In response to this command, Sonos first adds players to the group, then removes players from the group.
POST >> /groups/{groupId}/groups/setGroupMembers >> Use the setGroupMembers command in the groups namespace to replace the players in an existing group with a new set.
POST >> /households/{householdId}/groups/subscription >> Use this command to subscribe to events in the groups namespace.
DELETE >> /households/{householdId}/groups/subscription >> Use this command to unsubscribe to events in the groups namespace.
GET >> /groups/{groupId}/groupVolume >> Use the getVolume command in the groupVolume namespace to get the volume and mute state of a group.
POST >> /groups/{groupId}/groupVolume >> Use the setVolume command in the groupVolume namespace to set group volume to a specific level and unmute the group if muted. When your app sets the group volume, the group coordinator calculates the required changes to the volume level for each player in the group so that the result is the average volume level of the group as a whole. The group coordinator then adjusts its local volume and initiates network transactions with the other players in the group to adjust their volumes accordingly. While players adjust their volumes, the group coordinator may generate one or more groupVolume events. Since this command can generate additional network transactions and events, your app should optimize how often it is invoked to maintain a good user experience without flooding the network, such as when implementing a touch screen volume slider that controls a group of five players.
POST >> /groups/{groupId}/groupVolume/relative >> Use the setRelativeVolume command in the groupVolume namespace to increase or decrease group volume, and unmute the group if muted. Your app can use setRelativeVolume instead of setVolume when the user intent is to increase or decrease the group volume, but not to set the final volume to a particular value. For example, your app should use setRelativeVolume when the user presses hard volume plus/minus buttons on a mobile device. The group will automatically limit the final volume set within the valid range, so your app does not need to worry about that.
POST >> /groups/{groupId}/groupVolume/mute >> Use the setMute command in the groupVolume namespace to mute and unmute the group. The group’s mute state is independent of its group volume. For example a group’s mute state can be true although its group volume is still 20, and the user will not hear any audio coming from the group of players. Individual player volume values are stored by each player in the group while muted, which allows the group to retain the relative volume of players in the group. That is important information to preserve, since users may have carefully configured the individual player volumes in the group with a Sonos controller. Your app should not mute the group by calling setVolume with zero volume, otherwise the relative volume of players in the group will be lost. If some players in the group are muted and others are not, calling setMute to mute the group will mute all the players in the group. The individual player’s mute state prior to calling setMute is not preserved. To get the current group’s mute state, use the getVolume command or subscribe to the groupVolume event.
POST >> /groups/{groupId}/groupVolume/subscription >> Use this command to subscribe to events in the groupVolume namespace.
DELETE >> /groups/{groupId}/groupVolume/subscription >> Use this command to unsubscribe to events in the groupVolume namespace.
POST >> /groups/{groupId}/playlists >> The loadPlaylist command in the playlists namespace activates a playlist within the default playback session. This command interrupts any active private playback sessions. Sonos adds tracks from the playlist to the queue and activates the queue. This prevents your app from overwriting user-curated queues.
GET >> /households/{householdId}/playlists >> Use the getPlaylists command in the playlists namespace to get the list of Sonos playlists for a household. Playlists do not include pinned items (any non-playable containers pinned to My Sonos) or Sonos favorites.
POST >> /players/{playerId}/playerVolume/mute >> Use the setMute command in the playerVolume namespace to mute and unmute a player.
POST >> /players/{playerId}/playerVolume/relative >> Use the setRelativeVolume command in the playerVolume namespace to increase or decrease volume for a player and unmute the player if muted.
POST >> /playbackSessions/{sessionId}/playbackSession/skipToItem >> Use the skipToItem command in the playbackSession namespace to skip to the track with the specified itemId in a cloud queue and optionally seek and initiate playback. This command requires your app to have either created a new session or joined an existing session, and also loaded a cloud queue on the group with loadCloudQueue. Use playOnCompletion to start playing the cloud queue item being loaded, so your app doesn’t have to send an extra play command. Most of the times your app already has access to the track metadata of the cloud queue item that is being loaded. Use the optional trackMetadata parameter to provide that information so the group can start playing the track immediately after receiving the loadCloudQueue command. This optimization improves the user experience by starting playback before the player fetches tracks from the cloud queue server.
POST >> /playbackSessions/{sessionId}/playbackSession/refreshCloudQueue >> Use the refreshCloudQueue command in the playbackSession namespace to signal the player to re-fetch tracks from the cloud queue server centered around the current item. See the Cloud Queue API /itemWindow endpoint for details. This command requires your app to have either created a new session or joined an existing session, and also loaded a cloud queue on the group with loadCloudQueue. Your app should only use this command when it detects a change in the cloud queue content that should immediately be reflected in the group. For example, if a user removes the currently playing track with your app, use this command to remove the track from the group and stop it from playing. This helps provide a good user experience.
POST >> /groups/{groupId}/playbackSession/joinOrCreate >> Use the joinOrCreateSession command in the playbackSession namespace to join an existing session in the group, if the appId and appContext match the existing session’s. If there is no current session and no other source is playing, joinOrCreateSession creates a new session and joins it. While this same behavior can be achieved by first calling joinSession and then conditionally calling createSession, using joinOrCreateSession guarantees that another app cannot create a session in between the two commands. Use appContext to determine how multiple instances of your app can share control of a session. For example, if you provide a user account identifier as appContext, then two instances of your app logged into the same user account would be able to control the same session on a group. If you choose to implement your app to always provide an appContext that is unique for all app instances, then only one app instance can control a session at any time. Use customData to save information in the session that your app finds useful. For example, your app could store a playlist identifier in customData, so that another app instance could automatically load the right playlist when joining a session.
POST >> /groups/{groupId}/playbackSession/join >> Use the joinSession command in the playbackSession namespace to join an existing session in the group. To successfully join the session your app will have to provide the same appId and appContext that was used when creating the session.
GET >> groups/{groupId}/playbackMetadata >> Use this command to poll for metadata changes. This command returns a metadataStatus object for the target group.
DELETE >> /groups/{groupId}/playback/subscription >> Use this command to unsubscribe to events in the playback namespace.
POST >> /groups/{groupId}/playback/togglePlayPause >> Use the togglePlayPause command in the playback namespace to toggle the playback state on the given group, if possible. Upon completion of the command, the player sends playbackStatus events to all subscribers. When toggling from pause to play, this functions similar to the play command. When transitioning from play to pause, it functions like the pause command. See those commands for more details about the functionality of those states.
POST >> /groups/{groupId}/playback/subscription >> Use this command to subscribe to events in the playback namespace.
POST >> /groups/{groupId}/playback/skipToPreviousTrack >> Use the skipToPreviousTrack command in the playback namespace to skip to the previous track. Not all audio sources allow multiple tracks. For example, when a group is streaming an Internet radio station, there is no previous track to skip to. If you send a skipToPreviousTrack command when the audio source does not support multiple tracks, your app will receive an ERROR_PLAYBACK_FAILED, but audio will continue playing.
POST >> /groups/{groupId}/playback/skipToNextTrack >> Use the skipToNextTrack command in the playback namespace to skip to the next track. Not all audio sources allow multiple tracks. For example, when a group is streaming an Internet radio station, there is no next track to skip to. If you send a skipToNextTrack command when the audio source does not support multiple tracks, your app will receive an ERROR_PLAYBACK_FAILED, but the audio will continue playing.
POST >> /groups/{groupId}/playback/playMode >> Use the setPlayModes command in the playback namespace to change group play modes, such as repeat, repeat one track, shuffle, and crossfade. See Play Modes for details. Configure a play mode in the playModes array by adding a “true” or “false” value for the mode, or omit a play mode to leave it unchanged:
POST >> /groups/{groupId}/playback/seekRelative >> Use the seekRelative command in the playback namespace to seek to the a relative position in the current track. Optionally add the cloud queue itemId to target a specific track. Use itemId to ensure the group seeks on the current item. If the current item’s itemId does not match the one provided, the player returns ERROR_INVALID_OBJECT_ID.
POST >> /groups/{groupId}/playback/seek >> Use the seek command in the playback namespace to go to a specific position in the current track. Optionally add the cloud queue itemId to target a specific track. Use itemId to ensure the group seeks on the current item. If the current item’s itemId does not match the one provided, the player returns an ERROR_INVALID_OBJECT_ID error.
POST >> /groups/{groupId}/playback/pause >> Use the pause command in the playback namespace to pause group playback. After a successful pause command, if your app is subscribed to the playback namespace, it will receive a playbackStatus event with either PLAYBACK_STATE_PAUSED or PLAYBACK_STATE_IDLE, depending on the audio source loaded on the group.
POST >> /groups/{groupId}/playback/play >> Use the play command in the playback namespace to initiate group playback. After a successful play command, if your app is subscribed to the playback namespace, it may first receive a playbackStatus event with PLAYBACK_STATE_BUFFERING before another event with PLAYBACK_STATE_PLAYING. Sonos players will buffer the audio ahead of time when possible, in order to provide the shortest time to play for the user, and to prevent any audio gaps between tracks.
POST >> /groups/{groupId}/playback/lineIn >> Use the loadLineIn command in the playback namespace to change the current group source to the line-in source of a specified player. This can be be any player in the household that supports line-in. See Using Line-In on Sonos on the Sonos Support site for more details about the line-in capabilities of our players. You can tell whether a player has line-in capabilities with the LINE_IN value in the capabilities object. See the groups object for details. The player will switch away from the line-in source when the hardware detects that the user has physically unplugged the line-in cable.
GET >> /groups/{groupId}/playback >> Use the getPlaybackStatus command in the playback namespace get the current playback status (transport state) for the group, such as PLAYBACK_STATE_IDLE, PLAYBACK_STATE_BUFFERING, or PLAYBACK_STATE_PLAYING. See the playbackStatus object for details.
POST >> /households/{householdId}/musicServiceAccounts/match >> Use the match command in the musicServiceAccounts namespace to get the account ID of a music service user account from the player. All players in the household return the same accounts. Changes made to a player are automatically replicated throughout the household. The createSession and joinOrCreateSession commands in the  playbackSession namespace use the account returned by this command to specify the music service account to use for playback during the session. See Account Matching for implementation details.
GET >> /households >> Your app may have access to more than one household tied to an authorization token. Send a GET command to the household namespace endpoint to get a list of household IDs for which your app has access. See Authorize for details. The getHouseholds command requests information on the households that can be acted upon, based upon the access token used when calling this API. There are no parameters for this command.If successful, Sonos responds with an array of household objects.
POST >> /players/{playerId}/homeTheater/tvPowerState >> If the HDMI CEC bus is available, the setTvPowerState command in the homeTheater namespace will instruct the home theater capable device to send a CEC “TV On” command on the bus. The CEC specification does not require that the device acknowledges commands. Support for this command varies by TV manufacturer. If the TV sends a success or failure response to the player, the player provides it to your integration. Otherwise, the player returns a generic success response. Note that this command is only applicable for Sonos players that support HDMI ARC. Currently this is only the Beam. If your integration sends this command to a player that doesn’t support it, the player returns a globalError with an errorCode of: ERROR_UNSUPPORTED_NAMESPACE for non-home theater speakers, or ERROR_UNSUPPORTED_COMMAND for home theater speakers without CEC HDMI support.
POST >> /players/{playerId}/homeTheater/options >> Use setOptions in the homeTheater namespace to set homeTheaterOptions such as nightMode and enhanceDialog. See the homeTheaterOptions type for details.
POST >> /players/{playerId}/homeTheater >> Use the loadHomeTheaterPlayback command in the homeTheater namespace to signal the player to switch to its TV input (optical or HDMI) for playback. Note that this command is only applicable for Sonos players that support home theater inputs, such as the Playbar, Playbase, and Beam. If your integration sends this command to a player that doesn’t support it, the player returns a globalError with an errorCode of ERROR_UNSUPPORTED_NAMESPACE.
GET >> /players/{playerId}/homeTheater/options >> Use getOptions in the homeTheater namespace to get homeTheaterOptions such as nightMode and enhanceDialog. See the homeTheaterOptions type for details.